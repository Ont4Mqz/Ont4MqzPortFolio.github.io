<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Unity Scripts Viewer</title>
    <style>
        body {
            font-family: monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }

        details {
            margin-bottom: 15px;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px 10px;
            background-color: #2d2d2d;
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            color: #9cdcfe;
        }

        pre {
            overflow-x: auto;
            padding: 10px;
            background-color: #1e1e1e;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <h1>Unity Scripts Viewer</h1>
    <details>
        プレイヤーの移動・ジャンプ・回転・アニメーション制御
        <summary>PlayerController.cs</summary>
        <pre><code>
    using Unity.VisualScripting;
    using UnityEngine;
    using UnityEngine.InputSystem;
    using UnityEngine.SceneManagement;

    [RequireComponent(typeof(CharacterController))]
    public class PlayerController : MonoBehaviour
    {
    [Header("移動の速さ"), SerializeField] private float _speed = 3;//ステータス
    [Header("ジャンプする瞬間の速さ"), SerializeField] private float _jumpSpeed = 7;
    [Header("重力加速度"), SerializeField] private float _gravity = 15;
    [Header("落下時の速さ制限（Infinityで無制限）"), SerializeField] private float _fallSpeed = 10;
    [Header("落下の初速"), SerializeField] private float _initFallSpeed = 2;
    [Header("カメラのTransform"), SerializeField] private Transform _cameraTransform;
    [Header("GameClear演出呼び出し先"), SerializeField] private GameClearSpritAnimarion _clearAnimation;

    private Transform _transform;
    private CharacterController _characterController;
    private Vector2 _inputMove;
    private float _verticalVelocity;
    private bool _isGroundedPrev;

    private CameraSwitcher _cameraSwitcher;
    private ChaseBlockManager _chaseBlockManager;

    private bool _canMove = true;
    private Vector3 _currentFrameMoveAmount;

    private StageManager _stageManager;

    [SerializeField] private Animator _animator;
    [SerializeField] private TimeCounter timeCounter;

    // ← 追加: カメラが実際に2Dかを確実に判定するため、実機のカメラ投影を参照
    private bool IsCamera2D => Camera.main != null && Camera.main.orthographic;

    public void SetCanMove(bool canMove)
    {
    _canMove = canMove;
    }

    public Vector3 GetCurrentFrameMoveAmount()
    {
    return _currentFrameMoveAmount;
    }

    public void OnMove(InputAction.CallbackContext context)
    {
    if (!_canMove || (_stageManager != null && !_stageManager.IsPlaying))
    {
    _inputMove = Vector2.zero;
    return;
    }

    _inputMove = context.ReadValue<Vector2>
        ();
        }

        public void OnJump(InputAction.CallbackContext context)
        {
        // ← 修正: CameraSwitcher.IsCamera2D ではなく実際のカメラ投影を参照
        if (!IsCamera2D) return;
        if (_stageManager != null && !_stageManager.IsPlaying) return;
        if (!context.performed || !_characterController.isGrounded) return;

        _verticalVelocity = _jumpSpeed;

        if (_animator != null)
        {
        _animator.SetTrigger("JumpTrigger");
        _animator.SetBool("JumpBool", true);
        }
        }

        // public void DoJump()
        // {
        //     _verticalVelocity = _jumpSpeed;
        // }

        public void AnimetionSpeedUp()
        {
        if (_animator != null)
        {
        _animator.speed = 2.2f;
        }
        }

        public void ResetAnimetionSpeed()
        {
        if (_animator != null)
        {
        _animator.speed = 1f;
        }
        }


        public async void OnRightRotate(InputAction.CallbackContext context)
        {
        if (MenuUI.IsMenuActive) return;

        if (!context.performed || !IsCamera2D) return;
        if (_stageManager != null && !_stageManager.IsPlaying) return;
        if (!_chaseBlockManager.RevolveAllBlocks(true)) return;

        await _cameraSwitcher.RotateAroundTarget(-90f);

        _chaseBlockManager.SetMoveBlockLimits();
        }

        public async void OnLeftRotate(InputAction.CallbackContext context)
        {
        if (MenuUI.IsMenuActive) return;

        if (!context.performed || !IsCamera2D) return;
        if (_stageManager != null && !_stageManager.IsPlaying) return;
        if (!_chaseBlockManager.RevolveAllBlocks(false)) return;

        await _cameraSwitcher.RotateAroundTarget(90f);

        _chaseBlockManager.SetMoveBlockLimits();
        }

        private void OnControllerColliderHit(ControllerColliderHit hit)
        {
        if (GameManager.Instance.IsDamaged) return;

        if (hit.gameObject.layer == LayerMask.NameToLayer("DamageObj"))
        {
        hit.gameObject.GetComponent<DamageObject>
            ().DamageAndReload();
            }

            if (hit.gameObject.layer == LayerMask.NameToLayer("Stage") && hit.gameObject.layer == LayerMask.NameToLayer("Default") && hit.gameObject.layer == LayerMask.NameToLayer("MoveChaseBlock"))
            {
            if (_animator != null)
            {
            _animator.SetBool("JumpBool", false);
            }
            return;
            }
            {
            _animator.SetBool("JumpBool", false);
            }

            if (hit.gameObject.CompareTag("Gool"))
            {
            GameResultData.Instance.SetGameResult(StageManager.Instance.GetHpValue(), timeCounter.RemainingTime);

            // ClearMove を探して動画再生を呼ぶ
            ClearMove clearMove = FindObjectOfType<ClearMove>
                ();
                if (clearMove != null)
                {
                clearMove.PlayClearVideo();
                SetCanMove(false);
                }
                else
                {
                //SceneManager.LoadScene("Clear");
                //GameClear演出導入
                _clearAnimation.gameObject.SetActive(true);
                }
                }

                }

                private void Awake()
                {
                _transform = transform;
                _characterController = GetComponent<CharacterController>
                    ();
                    }

                    private void Start()
                    {
                    timeCounter = FindObjectOfType<TimeCounter>
                        ();
                        _cameraSwitcher = Camera.main.GetComponent<CameraSwitcher>
                            ();
                            _cameraTransform = Camera.main.transform;

                            _stageManager = StageManager.Instance;
                            _animator = GetComponentInChildren<Animator>
                                ();
                                if (_chaseBlockManager == null)
                                {
                                _chaseBlockManager = FindObjectOfType<ChaseBlockManager>
                                    ();
                                    }
                                    }

                                    private void Update()
                                    {
                                    if (MenuUI.IsMenuActive) return;

                                    // ← 修正: CameraSwitcher.IsCamera2D ではなく実カメラの orthographic を見て判定
                                    if (!IsCamera2D || !_canMove || (_stageManager != null && !_stageManager.IsPlaying))
                                    {
                                    _inputMove = Vector2.zero;
                                    _verticalVelocity = 0f;
                                    _currentFrameMoveAmount = Vector3.zero;

                                    if (_animator != null)
                                    {
                                    _animator.SetFloat("MoveFloat", 0f);
                                    _animator.SetBool("isMove", false);
                                    }


                                    return;
                                    }

                                    bool isGrounded = _characterController.isGrounded;

                                    if (isGrounded && !_isGroundedPrev)
                                    {
                                    _verticalVelocity = -_initFallSpeed;
                                    }
                                    else if (!isGrounded)
                                    {
                                    _verticalVelocity -= _gravity * Time.deltaTime;
                                    if (_verticalVelocity < -_fallSpeed)
                                    _verticalVelocity = -_fallSpeed;
                                    }

                                    _isGroundedPrev = isGrounded;

                                    Vector3 right = _cameraTransform.right;
                                    right.y = 0;
                                    right.Normalize();

                                    Vector3 moveDirection = right * _inputMove.x;

                                    _currentFrameMoveAmount = new Vector3(
                                    moveDirection.x * _speed * Time.deltaTime,
                                    _verticalVelocity * Time.deltaTime,
                                    moveDirection.z * _speed * Time.deltaTime
                                    );

                                    if (_chaseBlockManager != null && _chaseBlockManager.LimitMove(_currentFrameMoveAmount))
                                    {
                                    Vector3 prevPosition = transform.position;
                                    _characterController.Move(_currentFrameMoveAmount);
                                    _chaseBlockManager.MoveBlocks(transform.position - prevPosition);
                                    }
                                    else
                                    {
                                    _currentFrameMoveAmount.x = 0;
                                    _currentFrameMoveAmount.z = 0;
                                    _characterController.Move(_currentFrameMoveAmount);
                                    }

                                    if (_inputMove.x != 0)
                                    {
                                    _transform.rotation = Quaternion.LookRotation(moveDirection);
                                    }

                                    if (_animator != null)
                                    {
                                    // XZ方向の移動量の大きさ（Vector3）を計算
                                    float moveAmount = new Vector2(_currentFrameMoveAmount.x, _currentFrameMoveAmount.z).magnitude;

                                    // Animator の float パラメータ "MoveAmount" に設定
                                    _animator.SetFloat("MoveFloat", moveAmount);
                                    bool isMoveing = moveAmount > 0.01f;
                                    _animator.SetBool("MoveBool", isMoveing);

                                    }

                                    }

                                    public void SetChaseManager(ChaseBlockManager manager)
                                    {
                                    _chaseBlockManager = manager;
                                    }
                                    }

</code></pre>
    </details>

    <details>
        2D/3Dカメラ切り替え・公転・視点操作管理
        <summary>CameraSwitcher.cs</summary>
        <pre><code>
    using Cysharp.Threading.Tasks;
    using UnityEngine;
    using UnityEngine.InputSystem;

    public class CameraSwitcher : MonoBehaviour
    {
    //フラグ
    public static bool IsCamera2D { get; private set; } = false;
    public bool isCamera2D = false;

    //カメラ設定
    private Vector3 twoDimentionCamInitPos = new Vector3(4f, 2f, -10f);
    private Vector3 twoDimentionCamInitRot = new Vector3(0f, 0f, 0f);
    private Vector3 threeDimentionCamInitPos = new Vector3(0f, 10f, -10f);
    private Vector3 threeDimentionCamInitRot = new Vector3(30f, 0f, 0f);

    // 保存用
    private Vector3 savedThreeDPos;
    private Quaternion savedThreeDRot;
    private Vector3 savedTwoDPos;
    private Quaternion savedTwoDRot;
    private bool hasSavedThreeD = false;
    private bool hasSavedTwoD = false;

    //公転用のターゲット
    public Transform orbitTarget;

    //公転の設定値
    public float distance = 10f;
    public float rotationSpeed = 60f;
    public float initialElevation = 30f;

    private float currentElevation;
    private float currentRotation = 0f;

    private bool isPositionLocked = false;

    //遷移や入力制御用
    private Camera mainCamera;
    private KaitenMeikyu controls;
    private bool isTransitioning = false;
    private bool isOrbiting = false;
    private bool waitingForTransitionEnd = false;

    private float currentAngle = 0f;
    private float orbitTransitionTime = 0.15f;

    private Vector2 lookInput;
    private bool suppressSouthInput = false;
    private StageManager _stageManager;

    //切り替えの時のやつ
    [SerializeField] private GameObject HokenPanel;//アニメーションの切れ目を隠す用
    [SerializeField] private GameObject transitionObject;
    private Animator transitionAnimator;

    private void Awake()//初期化
    {
    mainCamera = Camera.main;
    controls = new KaitenMeikyu();
    currentElevation = initialElevation;
    }

    private void OnEnable()//On
    {
    controls.Enable();
    controls.Camera.Look.performed += OnLookPerformed;
    controls.Camera.Look.canceled += OnLookCanceled;
    controls.Camera._3DReset.performed += On3DResetPressed;
    controls.Camera.MoveCamera.performed += ctx => OnToggleCameraPressed().Forget();
    }

    private void OnDisable()//Off
    {
    controls.Camera.Look.performed -= OnLookPerformed;
    controls.Camera.Look.canceled -= OnLookCanceled;
    controls.Camera._3DReset.performed -= On3DResetPressed;
    controls.Camera.MoveCamera.performed -= ctx => OnToggleCameraPressed().Forget();
    controls.Disable();
    }

    private void Start()
    {
    _stageManager = StageManager.Instance;//ステージマネージャーの取得
    if (orbitTarget != null)
    {
    Vector3 dir = mainCamera.transform.position - orbitTarget.position;//公転の設定
    currentAngle = Mathf.Atan2(dir.x, dir.z) * Mathf.Rad2Deg;
    currentAngle = Mathf.Round(currentAngle / 90f) * 90f;
    }
    }

    private void LateUpdate()
    {
    if (isPositionLocked) return;
    if (_stageManager != null && !_stageManager.IsPlaying) return;//プレイしてたらいける

    if (!isCamera2D)//3Dカメラの操作ぐるぐる
    {
    currentRotation += lookInput.x * rotationSpeed * Time.deltaTime;
    Quaternion rotation = Quaternion.Euler(currentElevation, currentRotation, 0);
    Vector3 position = rotation * new Vector3(0, 0, -distance) + orbitTarget.position;

    mainCamera.transform.rotation = rotation;
    mainCamera.transform.position = position;
    }
    }

    private void OnLookPerformed(InputAction.CallbackContext ctx)
    {
    if (_stageManager != null && !_stageManager.IsPlaying) return;
    lookInput = ctx.ReadValue<Vector2>
        ();
        }
        private void OnLookCanceled(InputAction.CallbackContext ctx)
        {
        if (_stageManager != null && !_stageManager.IsPlaying) return;
        lookInput = Vector2.zero;
        }
        private void On3DResetPressed(InputAction.CallbackContext ctx)//3Dの時の視点リセット用
        {
        if (_stageManager != null && !_stageManager.IsPlaying) return;
        ResetView();
        suppressSouthInput = true;
        Invoke(nameof(ResetSouthSuppression), 0.1f);
        }
        private void ResetSouthSuppression() => suppressSouthInput = false;
        public bool IsSouthInputSuppressed => suppressSouthInput;

        public void UnlockCameraPosition() => isPositionLocked = false;//カメラ固定とか
        public void LockCameraPosition() => isPositionLocked = true;
        public void ResetElevation() => currentElevation = initialElevation;
        public void ResetView() { currentRotation = 0f; ResetElevation(); }

        private async UniTaskVoid OnToggleCameraPressed()//カメラ切り替え
        {
        if (isTransitioning || isOrbiting || waitingForTransitionEnd) return;
        if (_stageManager != null && !_stageManager.IsPlaying) return;

        if (transitionObject != null)
        {
        transitionObject.SetActive(true);
        transitionAnimator = transitionObject.GetComponent<Animator>
            ();
            }
            transitionAnimator.SetTrigger("TransitionStart");//閉じてくアニメーション開始
            waitingForTransitionEnd = true;
            }

            public async void EndTransition()
            {
            await ToggleCameraAfterTransition();
            HokenPanel.SetActive(true);
            Invoke(nameof(DisableHokenPanel), 0.05f);
            if (transitionAnimator != null)
            transitionAnimator.SetTrigger("TransitionNext");
            Invoke(nameof(DisableTransitionObject), 0f);
            }

            private void DisableHokenPanel() => HokenPanel.SetActive(false);
            private void DisableTransitionObject()
            {
            if (transitionObject != null) transitionObject.SetActive(false);
            waitingForTransitionEnd = false;
            }

            private async UniTask ToggleCameraAfterTransition()//実際の切り替え処理
            {
            if (MenuUI.IsMenuActive) return;

            isCamera2D = !isCamera2D;
            IsCamera2D = isCamera2D;
            isTransitioning = true;

            controls.Camera.Disable();
            LockCameraPosition();

            if (isCamera2D)
            {
            // 3D → 2D
            savedThreeDPos = mainCamera.transform.position;
            savedThreeDRot = mainCamera.transform.rotation;
            hasSavedThreeD = true;

            if (hasSavedTwoD)
            {
            mainCamera.transform.position = savedTwoDPos;
            mainCamera.transform.rotation = savedTwoDRot;
            }
            else
            {
            mainCamera.transform.position = twoDimentionCamInitPos;
            mainCamera.transform.rotation = Quaternion.Euler(twoDimentionCamInitRot);
            }
            }
            else
            {
            // 2D → 3D
            savedTwoDPos = mainCamera.transform.position;
            savedTwoDRot = mainCamera.transform.rotation;
            hasSavedTwoD = true;

            Vector3 dir = mainCamera.transform.forward;
            float yaw = Mathf.Atan2(dir.x, dir.z) * Mathf.Rad2Deg; // 2Dで見てた方向

            currentRotation = yaw;
            currentElevation = initialElevation;

            Vector3 pos = orbitTarget.position - (Quaternion.Euler(currentElevation, currentRotation, 0) * Vector3.forward * distance);
            mainCamera.transform.position = pos;
            mainCamera.transform.rotation = Quaternion.Euler(currentElevation, currentRotation, 0);

            hasSavedThreeD = true;
            }

            mainCamera.orthographic = isCamera2D;

            isTransitioning = false;
            if (!isCamera2D) { UnlockCameraPosition(); }
            else { UpdateCurrentAngleFromCamera(); }

            controls.Camera.Enable();
            }

            public async UniTask RotateAroundTarget(float angleDelta)//2Dの時の公転
            {
            if (!isCamera2D || isOrbiting || orbitTarget == null || isTransitioning) return;
            if (_stageManager != null && !_stageManager.IsPlaying) return;
            isOrbiting = true;
            float startAngle = currentAngle;
            float endAngle = currentAngle + angleDelta;
            float elapsed = 0f;
            while (elapsed < orbitTransitionTime)//移動を補完
            {
            elapsed += Time.deltaTime;
            float t = elapsed / orbitTransitionTime;
            float angle = Mathf.Lerp(startAngle, endAngle, t);
            UpdateOrbitPositionAtAngle(angle);
            await UniTask.Yield();
            }
            currentAngle = endAngle % 360f;
            UpdateOrbitPositionAtAngle(currentAngle);
            isOrbiting = false;
            }

            private void UpdateOrbitPositionAtAngle(float angle)//公転の位置更新
            {
            float radius = Vector3.Distance(mainCamera.transform.position, orbitTarget.position);
            float height = mainCamera.transform.position.y - orbitTarget.position.y;
            Vector3 offset = new Vector3(
            Mathf.Sin(angle * Mathf.Deg2Rad) * radius,
            height,
            Mathf.Cos(angle * Mathf.Deg2Rad) * radius
            );
            mainCamera.transform.position = orbitTarget.position + offset;
            mainCamera.transform.LookAt(orbitTarget.position);
            }

            private void UpdateCurrentAngleFromCamera()
            {
            Vector3 direction = mainCamera.transform.position - orbitTarget.position;
            currentAngle = Mathf.Atan2(direction.x, direction.z) * Mathf.Rad2Deg;
            currentAngle = Mathf.Round(currentAngle / 90f) * 90f;
            }

            public void ResetToInitialPosition()//ステージリロード時のカメラリセット
            {
            if (isCamera2D)
            {
            mainCamera.transform.position = twoDimentionCamInitPos;
            mainCamera.transform.rotation = Quaternion.Euler(twoDimentionCamInitRot);
            }
            else
            {
            mainCamera.transform.position = threeDimentionCamInitPos;
            mainCamera.transform.rotation = Quaternion.Euler(threeDimentionCamInitRot);
            currentRotation = 0f;          // 方向もリセット
            currentElevation = initialElevation;
            }
            }

            }

</code></pre>
    </details>

    <details>
        カメラに映るオブジェクトのNear/Far Clip制御
        <summary>ClippingObject.cs</summary>
        <pre><code>
    using UnityEngine;
    using System.Collections.Generic;

    public class ClippingObject : MonoBehaviour
    {
    [Header("対象のカメラ")]
    [SerializeField] private Camera targetCamera;

    [Header("コライダーグループ1")]
    [SerializeField] private List<Collider>
        group1Colliders;
        [SerializeField] private float group1NearClip = 0.3f;
        [SerializeField] private float group1FarClip = 1000f;

        [Header("コライダーグループ2")]
        [SerializeField] private List<Collider>
            group2Colliders;
            [SerializeField] private float group2NearClip = 0.3f;
            [SerializeField] private float group2FarClip = 500f;

            [Header("コライダーグループ3")]
            [SerializeField] private List<Collider>
                group3Colliders;
                [SerializeField] private float group3NearClip = 0.1f;
                [SerializeField] private float group3FarClip = 300f;

                [Header("コライダーグループ4")]
                [SerializeField] private List<Collider>
                    group4Colliders;
                    [SerializeField] private float group4NearClip = 1f;
                    [SerializeField] private float group4FarClip = 100f;

                    [Header("コライダーグループ5")]
                    [SerializeField] private List<Collider>
                        group5Colliders;
                        [SerializeField] private float group5NearClip = 0.5f;
                        [SerializeField] private float group5FarClip = 200f;

                        [Header("デフォルトClipping値（条件未達時）")]
                        [SerializeField] private float defaultNearClip = 0.3f;
                        [SerializeField] private float defaultFarClip = 1000f;

                        [Header("Clippingを無視するオブジェクト")]
                        [SerializeField] private List<GameObject>
                            ignoreObjects;

                            private bool isResetApplied = false;

                            private void Start()
                            {
                            targetCamera = Camera.main;
                            }

                            private void Update()
                            {
                            if (targetCamera == null) return;

                            if (!IsValidCameraCondition())
                            {
                            if (!isResetApplied)
                            {
                            ResetClipping();
                            isResetApplied = true;
                            }
                            }
                            else
                            {
                            isResetApplied = false;
                            }
                            }

                            private void OnTriggerEnter(Collider other)
                            {
                            if (IsValidCameraCondition())
                            {
                            CheckCollision(other);
                            }
                            }

                            private void OnTriggerStay(Collider other)
                            {
                            if (IsValidCameraCondition())
                            {
                            CheckCollision(other);
                            }
                            }

                            private void OnCollisionEnter(Collision collision)
                            {
                            if (IsValidCameraCondition())
                            {
                            CheckCollision(collision.collider);
                            }
                            }

                            private void OnCollisionStay(Collision collision)
                            {
                            if (IsValidCameraCondition())
                            {
                            CheckCollision(collision.collider);
                            }
                            }

                            private void CheckCollision(Collider col)
                            {
                            if (targetCamera == null) return;

                            // 例外オブジェクトに含まれていたらスキップ
                            if (ignoreObjects.Contains(col.gameObject)) return;

                            if (group1Colliders.Contains(col))
                            {
                            SetClipping(group1NearClip, group1FarClip);
                            }
                            else if (group2Colliders.Contains(col))
                            {
                            SetClipping(group2NearClip, group2FarClip);
                            }
                            else if (group3Colliders.Contains(col))
                            {
                            SetClipping(group3NearClip, group3FarClip);
                            }
                            else if (group4Colliders.Contains(col))
                            {
                            SetClipping(group4NearClip, group4FarClip);
                            }
                            else if (group5Colliders.Contains(col))
                            {
                            SetClipping(group5NearClip, group5FarClip);
                            }
                            }

                            private bool IsValidCameraCondition()
                            {
                            float yPos = targetCamera.transform.position.y;
                            float yRot = targetCamera.transform.eulerAngles.y;

                            bool isHeightOk = Mathf.Abs(yPos - 2f) < 0.01f;
                            bool isRotationOk =
                            Mathf.Abs(yRot - 0f) < 5f ||
                            Mathf.Abs(yRot - 90f) < 5f ||
                            Mathf.Abs(yRot - 180f) < 5f ||
                            Mathf.Abs(yRot - 270f) < 5f;

                            return isHeightOk && isRotationOk;
                            }

                            private void SetClipping(float near, float far)
                            {
                            targetCamera.nearClipPlane = near;
                            targetCamera.farClipPlane = far;
                            }

                            private void ResetClipping()
                            {
                            targetCamera.nearClipPlane = defaultNearClip;
                            targetCamera.farClipPlane = defaultFarClip;
                            }
                            }

</code></pre>
    </details>

    <details>
        ステージごとのUIの表示・非表示管理
        <summary>GTUIManager.cs</summary>
        <pre><code>
    using UnityEngine;

    [System.Serializable]
    public class StageUISet
    {
    [Header("このステージで表示するUIたち")]
    public GameObject ui1;
    public GameObject ui2;
    }

    public class GTUIManager : MonoBehaviour
    {
    [Header("ステージごとのUIセット (1〜7)")]
    [SerializeField] private StageUISet[] stageUISets = new StageUISet[7];

    private void Start()
    {
    int stageIndex = StageData.SelectedStageIndex; // ← StageManagerと同じ仕組みを利用
    ShowStageUI(stageIndex);
    }

    public void ShowStageUI(int stageIndex)
    {
    // まず全部非表示にする
    for (int i = 0; i < stageUISets.Length; i++)
    {
    if (stageUISets[i].ui1 != null) stageUISets[i].ui1.SetActive(false);
    if (stageUISets[i].ui2 != null) stageUISets[i].ui2.SetActive(false);
    }

    // ステージ番号に対応するUIだけ表示
    if (stageIndex > 0 && stageIndex <= stageUISets.Length)
    {
    StageUISet set = stageUISets[stageIndex - 1];
    if (set.ui1 != null) set.ui1.SetActive(true);
    if (set.ui2 != null) set.ui2.SetActive(true);
    }
    else
    {
    Debug.LogWarning($"ステージ番号 {stageIndex} は範囲外です");
    }
    }
    }

</code></pre>
    </details>

    <details>
        壁に当たったら回転する移動型敵キャラクターの制御
        <summary>KurukuruEnemy.cs</summary>
        <pre><code>
    using UnityEngine;

    public class KurukuruEnemy : MonoBehaviour
    {
    [Header("移動速度")]
    [SerializeField] private float moveSpeed = 3f;

    [Header("回転速度 (度/秒)")]
    [SerializeField] private float rotationSpeed = 180f;

    [Header("無視するコライダー（地面など）")]
    [SerializeField] private Collider[] ignoreColliders;

    private bool isRotating = false;
    private Quaternion targetRotation;

    private void Update()
    {
    // XとZの回転を常に0に固定（姿勢が崩れないように）
    Vector3 euler = transform.eulerAngles;
    transform.rotation = Quaternion.Euler(0f, euler.y, 0f);

    if (!isRotating)
    {
    transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);
    }
    else
    {
    RotateEnemy();
    }
    }

    private void OnCollisionEnter(Collision collision)
    {
    foreach (var ignore in ignoreColliders)
    {
    if (collision.collider == ignore)
    return;
    }

    if (!isRotating)
    {
    StartRotation();
    }
    }

    private void StartRotation()
    {
    isRotating = true;
    float newYRotation = transform.eulerAngles.y + 180f;
    targetRotation = Quaternion.Euler(0f, newYRotation, 0f);
    }

    private void RotateEnemy()
    {
    float step = rotationSpeed * Time.deltaTime;
    transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, step);

    // XZ軸を固定しながらYのみ制御
    Vector3 euler = transform.rotation.eulerAngles;
    transform.rotation = Quaternion.Euler(0f, euler.y, 0f);

    if (Quaternion.Angle(transform.rotation, targetRotation) < 0.1f)
    {
    transform.rotation = targetRotation;
    isRotating = false;
    }
    }
    }

</code></pre>
    </details>

    <details>
        Animation Event からカメラスイッチの終了処理を呼ぶ
        <summary>TransitionEventReceiver.cs</summary>
        <pre><code>
    using UnityEngine;

    public class TransitionEventReceiver : MonoBehaviour
    {
    [SerializeField] private CameraSwitcher cameraSwitcher;

    // Animation Event から呼ばれる
    public void EndTransition()
    {
    if (cameraSwitcher != null)
    cameraSwitcher.EndTransition();
    }
    }

</code></pre>
    </details>

    <details>
        BGM再生・ループ設定管理
        <summary>BGMManager.cs</summary>
        <pre><code>
    using UnityEngine;

    public class BGMManager : MonoBehaviour
    {
    [Header("再生するBGM")]
    [SerializeField] private AudioClip bgmClip;

    [Header("オプション")]
    [SerializeField] private bool loop = true;

    private AudioSource audioSource;

    void Awake()
    {
    // AudioSourceを取得または追加
    audioSource = GetComponent<AudioSource>
        ();
        if (audioSource == null)
        audioSource = gameObject.AddComponent<AudioSource>
            ();

            // AudioSourceの設定
            audioSource.clip = bgmClip;
            audioSource.loop = loop;
            audioSource.playOnAwake = false;
            audioSource.volume = 0.5f; // 任意調整

            // BGMを再生
            if (bgmClip != null)
            audioSource.Play();
            }
            }

</code></pre>
    </details>

    <details>
        2D/3DモードUI切替とゲームオーバーUI管理
        <summary>OperationManager.cs</summary>
        <pre><code>
    using UnityEngine;

    public class OperationManager : MonoBehaviour
    {
    [Header("2Dモードで表示するUI")]
    public GameObject howtoUI2D;       // 2Dモード時に表示するUI

    [Header("3Dモードで表示するUI")]
    public GameObject howtoUI3D;       // 3Dモード時に表示するUI

    [Header("ゲームオーバー時に表示するUIパネル")]
    public GameObject gameOverPanel;   // ゲームオーバー判定に使うパネル（Active状態を監視）

    [Header("ゲームオーバー時に表示する説明UI")]
    public GameObject gameOverUI;      // ゲームオーバー時に表示する説明UI

    private bool lastIsCamera2D;       // 前回のカメラ状態

    private void Start()
    {
    if (IsGameOverActive())             // ゲームオーバーパネルが既に表示中なら
    {
    ShowGameOverUI();                // ゲームオーバー説明UIだけ表示
    return;                          // 他のUI初期化は行わない
    }

    lastIsCamera2D = CameraSwitcher.IsCamera2D; // 現在のカメラ状態を保存
    ApplyUIState(lastIsCamera2D);               // 初期UI反映
    }

    private void Update()
    {
    if (IsGameOverActive())               // ゲームオーバーパネルがアクティブなら
    {
    ShowGameOverUI();                  // ゲームオーバーUI表示
    return;                            // 2D/3D切替はしない
    }

    // 通常時の2D/3D切替処理
    if (CameraSwitcher.IsCamera2D != lastIsCamera2D)
    {
    lastIsCamera2D = CameraSwitcher.IsCamera2D;
    ApplyUIState(lastIsCamera2D);
    }
    }

    private bool IsGameOverActive()
    {
    return gameOverPanel != null && gameOverPanel.activeSelf; // ゲームオーバーパネルが表示中か
    }

    private void ShowGameOverUI()
    {
    if (gameOverUI != null) gameOverUI.SetActive(true);     // ゲームオーバー説明UIを表示
    if (howtoUI2D != null) howtoUI2D.SetActive(false);      // 2D用UIは非表示
    if (howtoUI3D != null) howtoUI3D.SetActive(false);      // 3D用UIも非表示
    }

    private void ApplyUIState(bool is2D)
    {
    if (howtoUI2D != null) howtoUI2D.SetActive(is2D);       // 2DモードUIの表示切替
    if (howtoUI3D != null) howtoUI3D.SetActive(!is2D);      // 3DモードUIの表示切替
    if (gameOverUI != null) gameOverUI.SetActive(false);    // 通常時はゲームオーバーUIを非表示
    }
    }

</code></pre>
    </details>

</body>
</html>
